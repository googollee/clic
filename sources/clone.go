package sources

import (
	"fmt"
	"reflect"

	"github.com/googollee/clic/structtags"
)

// newFromFields creates a new instance with the type generated by an name-ordered array of `fields`.
func newFromFields(fields []structtags.Field, index int, tagFmt string) reflect.Value {
	type NamedValue struct {
		name  string
		value reflect.Value
	}
	var wantValues []NamedValue

	for len(fields) > 0 {
		end := findEndFieldHaveSameIndex(fields, index)

		if end == 1 && index == len(fields[0].Name)-1 {
			wantValues = append(wantValues, NamedValue{
				name:  fields[0].Name[index],
				value: reflect.ValueOf(fields[0]),
			})
			fields = fields[1:]
			continue
		}

		wantValues = append(wantValues, NamedValue{
			name:  fields[0].Name[index],
			value: newFromFields(fields[:end], index+1, tagFmt).Elem(),
		})

		fields = fields[end:]
	}

	wantFields := make([]reflect.StructField, 0, len(wantValues))
	for _, namedValue := range wantValues {
		field := reflect.StructField{
			Name: "Field_" + namedValue.name,
			Type: namedValue.value.Type(),
			Tag:  reflect.StructTag(fmt.Sprintf(tagFmt, namedValue.name)),
		}
		wantFields = append(wantFields, field)
	}

	typ := reflect.StructOf(wantFields)
	ret := reflect.New(typ)
	for _, namedValue := range wantValues {
		ret.Elem().FieldByName("Field_" + namedValue.name).Set(namedValue.value)
	}

	return ret
}

func findEndFieldHaveSameIndex(fields []structtags.Field, index int) (end int) {
	if len(fields) == 0 || index >= len(fields[0].Name) {
		return
	}

	fieldName := fields[0].Name[index]

	for end = 1; end < len(fields); end++ {
		if index >= len(fields[end].Name) || fields[end].Name[index] != fieldName {
			return
		}
	}

	return
}
